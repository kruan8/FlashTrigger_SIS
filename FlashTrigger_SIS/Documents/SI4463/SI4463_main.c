/*  
 ** ============================================================================  
 **  
 ** FILE  
 **  main.c  
 **  
 ** DESCRIPTION  
 **  Main file for the SRW motherboard main MCU project.  
 **  
 ** CREATED  
 **  Silicon Laboratories Hungary Ltd  
 **  
 ** COPYRIGHT  
 **  Copyright 2012 Silicon Laboratories, Inc.  
 ** http://www.silabs.com  
 **  
 ** ============================================================================  
 */   
   
   
/*------------------------------------------------------------------------*/   
/*            INCLUDE                                       */   
/*------------------------------------------------------------------------*/   
#include "compiler_defs.h"   
#include "c8051f960_defs.h"   
#include "hardware_defs.h"   
#include "control_IO.h"   
#include "spi.h"   
#include "Si446x_B0_defs.h"   
#include "ezrp_next_api.h"   
#include "modem_params.h"   
   
// Define capacitor bank value   
#define CAP_BANK_VALUE    0x48    // Capacitor bank value for adjusting the XTAL frequency   
                                  // Note that it may varies on different test cards   
   
   
/*------------------------------------------------------------------------*/   
/*            GLOBAL variables                        */   
/*------------------------------------------------------------------------*/   
   
// Set up modem parameters database; data is retrieved from modem_params.h header file which is   
// automatically generated by the WDS (Wireless Development Suite)   
SEG_CODE U8 ModemTrx1[] = {7, MODEM_MOD_TYPE_7};   
SEG_CODE U8 ModemTrx2[] = {5, MODEM_CLKGEN_BAND_5};   
SEG_CODE U8 ModemTrx3[] = {11, SYNTH_PFDCP_CPFF_11};   
SEG_CODE U8 ModemTrx4[] = {12, FREQ_CONTROL_INTE_12};   
   
SEG_CODE U8 ModemRx1[] = {11, MODEM_MDM_CTRL_11};   
SEG_CODE U8 ModemRx2[] = {14, MODEM_BCR_OSR_1_14};   
SEG_CODE U8 ModemRx3[] = {12, MODEM_AFC_GEAR_12};   
SEG_CODE U8 ModemRx4[] = {5, MODEM_AGC_CONTRL_5};   
SEG_CODE U8 ModemRx4_1[] = {7, MODEM_AGC_WINDOW_SIZE_7};   
SEG_CODE U8 ModemRx5[] = {9, MODEM_FSK4_GAIN1_9};   
SEG_CODE U8 ModemRx6[] = {8, MODEM_OOK_PDTC_8};   
SEG_CODE U8 ModemRx7[] = {8, MODEM_RAW_SEARCH_8};   
SEG_CODE U8 ModemRx8[] = {6, MODEM_ANT_DIV_MODE_6};   
SEG_CODE U8 ModemRx9[] = {13, MODEM_CHFLT_RX1_CHFLT_COE13_7_0_13};   
SEG_CODE U8 ModemRx10[] = {13, MODEM_CHFLT_RX1_CHFLT_COE4_7_0_13};   
SEG_CODE U8 ModemRx11[] = {13, MODEM_CHFLT_RX2_CHFLT_COE13_7_0_13};   
SEG_CODE U8 ModemRx12[] = {13, MODEM_CHFLT_RX2_CHFLT_COE4_7_0_13};   
   
   
/*------------------------------------------------------------------------*/   
/*            LOCAL function prototypes                         */   
/*------------------------------------------------------------------------*/   
void MCU_Init(void);   
   
   
/*------------------------------------------------------------------------*/   
/*            MAIN function                             */   
/*------------------------------------------------------------------------*/   
   
void main(void)   
{   
  SEGMENT_VARIABLE(wDelay, U16, SEG_XDATA);   
  SEGMENT_VARIABLE(bButtonNumber, U8, SEG_XDATA);   
  BIT fValidPacket;   
   
  //initialize the MCU peripherals   
  MCU_Init();   
  InitIO();   
   
  // Reset the radio   
  EZRP_PWRDN = 1;   
  // Wait ~300us (SDN pulse width)   
  for(wDelay=0; wDelay<330; wDelay++);   
  // Wake up the chip from SDN   
  EZRP_PWRDN = 0;   
   
  // Wait for POR (power on reset); ~5ms   
  for(wDelay=0; wDelay<5500; wDelay++);   
   
  // Start the radio   
  abApi_Write[0] = CMD_POWER_UP;          // Use API command to power up the radio IC   
  abApi_Write[1] = 0x01;              // Write global control registers   
  abApi_Write[2] = 0x00;              // Write global control registers   
  bApi_SendCommand(3,abApi_Write);        // Send command to the radio IC   
  // Wait for boot   
  if (vApi_WaitforCTS())                // Wait for CTS   
  {   
    while (1) {}    // Stop if radio power-up error   
  }   
   
  // Read ITs, clear pending ones   
  abApi_Write[0] = CMD_GET_INT_STATUS;      // Use interrupt status command   
  abApi_Write[1] = 0;               // Clear PH_CLR_PEND   
  abApi_Write[2] = 0;               // Clear MODEM_CLR_PEND   
  abApi_Write[3] = 0;               // Clear CHIP_CLR_PEND   
  bApi_SendCommand(4,abApi_Write);        // Send command to the radio IC   
  bApi_GetResponse(8, abApi_Read );         // Make sure that CTS is ready then get the response   
   
  // Set TRX parameters of the radio IC; data retrieved from the WDS-generated modem_params.h header file   
  bApi_SendCommand(ModemTrx1[0],&ModemTrx1[1]);       // Send API command to the radio IC   
  vApi_WaitforCTS();                    // Wait for CTS   
  bApi_SendCommand(ModemTrx2[0],&ModemTrx2[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemTrx3[0],&ModemTrx3[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemTrx4[0],&ModemTrx4[1]);   
  vApi_WaitforCTS();   
   
  // Set Rx parameters of the radio IC   
  bApi_SendCommand(ModemRx1[0],&ModemRx1[1]);       // Send API command to the radio IC   
  vApi_WaitforCTS();                    // Wait for CTS   
  bApi_SendCommand(ModemRx2[0],&ModemRx2[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemRx3[0],&ModemRx3[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemRx4[0],&ModemRx4[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemRx4_1[0],&ModemRx4_1[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemRx5[0],&ModemRx5[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemRx6[0],&ModemRx6[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemRx7[0],&ModemRx7[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemRx8[0],&ModemRx8[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemRx9[0],&ModemRx9[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemRx10[0],&ModemRx10[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemRx11[0],&ModemRx11[1]);   
  vApi_WaitforCTS();   
  bApi_SendCommand(ModemRx12[0],&ModemRx12[1]);   
  vApi_WaitforCTS();   
   
  // Enable packet received and CRC error interrupt only   
  abApi_Write[0] = CMD_SET_PROPERTY;      // Use property command   
  abApi_Write[1] = PROP_INT_CTL_GROUP;    // Select property group   
  abApi_Write[2] = 4;               // Number of properties to be written   
  abApi_Write[3] = PROP_INT_CTL_ENABLE;   // Specify property   
  abApi_Write[4] = 0x01;              // INT_CTL: PH interrupt enabled   
  abApi_Write[5] = 0x18;              // INT_CTL_PH: PH PACKET_RX & CRC2_ERR interrupt enabled   
  abApi_Write[6] = 0x00;              // INT_CTL_MODEM: -   
  abApi_Write[7] = 0x00;              // INT_CTL_CHIP_EN: -   
  bApi_SendCommand(8,abApi_Write);        // Send API command to the radio IC   
  vApi_WaitforCTS();                // Wait for CTS   
   
  // Configure Fast response registers   
  abApi_Write[0] = CMD_SET_PROPERTY;        // Use property command   
  abApi_Write[1] = PROP_FRR_CTL_GROUP;      // Select property group   
  abApi_Write[2] = 4;               // Number of properties to be written   
  abApi_Write[3] = PROP_FRR_CTL_A_MODE;     // Specify property (1st)   
  abApi_Write[4] = 0x04;              // FRR A: PH IT pending   
  abApi_Write[5] = 0x06;              // FRR B: Modem IT pending   
  abApi_Write[6] = 0x0A;              // FRR C: Latched RSSI   
  abApi_Write[7] = 0x00;              // FRR D: disabled   
  bApi_SendCommand(8,abApi_Write);        // Send API command to the radio IC   
  vApi_WaitforCTS();                // Wait for CTS   
   
  //Set packet content   
  //Set preamble length   
  abApi_Write[0] = CMD_SET_PROPERTY;        // Use property command   
  abApi_Write[1] = PROP_PREAMBLE_GROUP;     // Select property group   
  abApi_Write[2] = 1;               // Number of properties to be written   
  abApi_Write[3] = PROP_PREAMBLE_CONFIG_STD_1;  // Specify property   
  abApi_Write[4] = 20;              // 20 bits preamble detection threshold   
  bApi_SendCommand(5,abApi_Write);        // Send API command to the radio IC   
  vApi_WaitforCTS();                // Wait for CTS   
   
  // Set preamble pattern   
  abApi_Write[0] = CMD_SET_PROPERTY;        // Use property command   
  abApi_Write[1] = PROP_PREAMBLE_GROUP;     // Select property group   
  abApi_Write[2] = 1;               // Number of properties to be written   
  abApi_Write[3] = PROP_PREAMBLE_CONFIG;      // Specify property   
  abApi_Write[4] = 0x31;              // Use `1010` pattern, length defined in bytes   
  bApi_SendCommand(5,abApi_Write);        // Send API command to the radio IC   
  vApi_WaitforCTS();                // Wait for CTS   
   
  // Set sync word   
  abApi_Write[0] = CMD_SET_PROPERTY;        // Use property command   
  abApi_Write[1] = PROP_SYNC_GROUP;       // Select property group   
  abApi_Write[2] = 3;               // Number of properties to be written   
  abApi_Write[3] = PROP_SYNC_CONFIG;        // Specify property   
  abApi_Write[4] = 0x01;              // SYNC_CONFIG: 2 bytes sync word   
  abApi_Write[5] = 0xB4;              // SYNC_BITS_31_24: 1st sync byte: 0x2D; NOTE: LSB transmitted first!   
  abApi_Write[6] = 0x2B;              // SYNC_BITS_23_16: 2nd sync byte: 0xD4; NOTE: LSB transmitted first!   
  bApi_SendCommand(7,abApi_Write);        // Send command to the radio IC   
  vApi_WaitforCTS();                // Wait for CTS   
   
  // General packet config (set bit order)   
  abApi_Write[0] = CMD_SET_PROPERTY;        // Use property command   
  abApi_Write[1] = PROP_PKT_GROUP;        // Select property group   
  abApi_Write[2] = 1;               // Number of properties to be written   
  abApi_Write[3] = PROP_PKT_CONFIG1;        // Specify property   
  abApi_Write[4] = 0x00;              // Payload data goes MSB first   
  bApi_SendCommand(5,abApi_Write);        // Send command to the radio IC   
  vApi_WaitforCTS();                // Wait for CTS   
   
  // Set RSSI latch to sync word   
  abApi_Write[0] = CMD_SET_PROPERTY;        // Use property command   
  abApi_Write[1] = PROP_MODEM_GROUP;        // Select property group   
  abApi_Write[2] = 1;               // Number of properties to be written   
  abApi_Write[3] = PROP_MODEM_RSSI_CONTROL;   // Specify property   
  abApi_Write[4] = 0x12;              // RSSI average over 4 bits, latch at sync detect   
  bApi_SendCommand(5,abApi_Write);        // Send API command to the radio IC   
  vApi_WaitforCTS();                // Wait for CTS   
   
  // Configure the GPIOs   
  abApi_Write[0] = CMD_GPIO_PIN_CFG;        // Use GPIO pin configuration command   
#ifdef ONE_SMA_WITH_RF_SWITCH   
  // If RF switch is used   
  // Select Tx state to GPIO2, Rx state to GPIO0   
  abApi_Write[1] = 0x21;              // Configure GPIO0 as Rx state   
  abApi_Write[2] = 0x13;              // Configure GPIO1 as Tx data   
  abApi_Write[3] = 0x20;              // Configure GPIO2 as Tx state   
  abApi_Write[4] = 0x10;              // Configure GPIO3 as Tx data CLK   
#else   
  abApi_Write[1] = 0x10;              // Configure GPIO0 as Tx data CLK   
  abApi_Write[2] = 0x13;              // Configure GPIO1 as Tx data   
  abApi_Write[3] = 0x20;              // Configure GPIO2 as Tx state   
  abApi_Write[4] = 0x21;              // Configure GPIO3 as Rx state   
#endif   
  bApi_SendCommand(5,abApi_Write);        // Send command to the radio IC   
  vApi_WaitforCTS();   
   
  // Adjust XTAL clock frequency   
  abApi_Write[0] = CMD_SET_PROPERTY;        // Use property command   
  abApi_Write[1] = PROP_GLOBAL_GROUP;       // Select property group   
  abApi_Write[2] = 1;               // Number of properties to be written   
  abApi_Write[3] = PROP_GLOBAL_XO_TUNE;     // Specify property   
  abApi_Write[4] = CAP_BANK_VALUE;        // Set cap bank value to adjust XTAL clock frequency   
  bApi_SendCommand(5,abApi_Write);        // Send command to the radio IC   
  vApi_WaitforCTS();                // Wait for CTS   
   
  // Read ITs, clear pending ones   
  abApi_Write[0] = CMD_GET_INT_STATUS;  // Use interrupt status command   
  abApi_Write[1] = 0;           // Clear PH_CLR_PEND   
  abApi_Write[2] = 0;           // Clear MODEM_CLR_PEND   
  abApi_Write[3] = 0;           // Clear CHIP_CLR_PEND   
  bApi_SendCommand(4,abApi_Write);    // Send command to the radio IC   
  bApi_GetResponse(8,abApi_Read);     // Get the response   
   
  // Start Rx   
  abApi_Write[0] = CMD_START_RX;      // Use start Rx command   
  abApi_Write[1] = 0;           // Set channel number   
  abApi_Write[2] = 0x00;          // Start Rx immediately   
  abApi_Write[3] = 0x00;          // 8 bytes to receive   
  abApi_Write[4] = 0x08;          // 8 bytes to receive   
  abApi_Write[5] = 0x00;          // No change if Rx timeout   
  abApi_Write[6] = 0x03;          // Ready state after Rx   
  abApi_Write[7] = 0x03;          // Ready state if Rx invalid   
  bApi_SendCommand(8,abApi_Write);    // Send API command to the radio IC   
  vApi_WaitforCTS();            // Wait for CTS   
   
  // Turn off LEDs   
  ClearLed(1);   
  ClearLed(2);   
  ClearLed(3);   
  ClearLed(4);   
   
  while(1)   
  {   
   
    if(EZRP_NIRQ == 0)   
    {   
      // Read PH IT registers to see the cause for the IT   
      abApi_Write[0] = CMD_GET_PH_STATUS;   // Use packet handler status command   
      abApi_Write[1] = 0x00;          // Dummy byte for a proper CTS response   
      bApi_SendCommand(2,abApi_Write);    // Send command to the radio IC   
      bApi_GetResponse(1,abApi_Read);     // Make sure that CTS is ready then get the response   
   
      if((abApi_Read[0] & 0x10) == 0x10)    // Check if packet received   
      {// Packet received   
        // Get RSSI   
        bApi_GetFastResponseRegister(CMD_FAST_RESPONSE_REG_C,1,abApi_Read);   
        // Read the FIFO   
        bApi_ReadRxDataBuffer(8,abApi_Read);   
   
        fValidPacket = 0;   
        // Check the packet content   
        if ((abApi_Read[0]=='B') && (abApi_Read[1]=='U') && (abApi_Read[2]=='T') && (abApi_Read[3]=='T') && (abApi_Read[4]=='O') && (abApi_Read[5]=='N'))   
        {   
          bButtonNumber = abApi_Read[6] & 0x07; // Get button info   
          if((bButtonNumber > 0) && (bButtonNumber < 5))   
          {   
            SetLed(bButtonNumber);          // Turn on the appropriate LED   
            for(wDelay=0; wDelay<30000; wDelay++);  // Wait to show LED   
            ClearLed(bButtonNumber);        // Turn off the corresponding LED   
            fValidPacket = 1;   
          }   
        }   
        // Packet content is not what was expected   
        if(fValidPacket == 0)   
        {   
          SetLed(1);                // Blink all LEDs   
          SetLed(2);   
          SetLed(3);   
          SetLed(4);   
          for(wDelay=0; wDelay<30000; wDelay++);   
          ClearLed(1);   
          ClearLed(2);   
          ClearLed(3);   
          ClearLed(4);   
        }   
      }   
   
      // Read ITs, clear pending ones   
      abApi_Write[0] = CMD_GET_INT_STATUS;  // Use interrupt status command   
      abApi_Write[1] = 0;           // Clear PH_CLR_PEND   
      abApi_Write[2] = 0;           // Clear MODEM_CLR_PEND   
      abApi_Write[3] = 0;           // Clear CHIP_CLR_PEND   
      bApi_SendCommand(4,abApi_Write);    // Send command to the radio IC   
      bApi_GetResponse(8,abApi_Read);     // Get the response   
   
      // Start Rx   
      abApi_Write[0] = CMD_START_RX;      // Use start Rx command   
      abApi_Write[1] = 0;           // Set channel number   
      abApi_Write[2] = 0x00;          // Start Rx immediately   
      abApi_Write[3] = 0x00;          // 8 bytes to receive   
      abApi_Write[4] = 0x08;          // 8 bytes to receive   
      abApi_Write[5] = 0x00;          // No change if Rx timeout   
      abApi_Write[6] = 0x03;          // Ready state after Rx   
      abApi_Write[7] = 0x03;          // Ready if Rx invalid   
      bApi_SendCommand(8,abApi_Write);    // Send API command to the radio IC   
      vApi_WaitforCTS();            // Wait for CTS   
    }   
   
  }   
}   
   
   
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
  +  
  + FUNCTION NAME:  void MCU_Init(void)  
  
  +  
  + DESCRIPTION:    MCU initialization function  
  +  
  + RETURN:         None  
  +  
  + NOTES:          None  
  +  
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/   
void MCU_Init(void)   
{   
   
   
  //Init Internal Precisious Oscillator (24.5MHz)   
  SFRPAGE = CONFIG_PAGE;   
  FLSCL     = 0x40;   
   
  // Init master hw SPI interface (SCK clock: 2.45MHz)   
  // Init SPI1 (Radio)   
  SFRPAGE   = SPI1_PAGE;   
  SPI1CFG   = 0x40;   
  SPI1CN    = 0x01;   
  SPI1CKR   = 0x04;   
  // Init SPI0 (LCD and EBID)   
  SFRPAGE   = LEGACY_PAGE;   
  SPI0CFG   = 0x40;   
  SPI0CN    = 0x01;   
  SPI0CKR   = 0x04;   
   
   
  SFRPAGE = LEGACY_PAGE;   
  OSCICN |= 0x80;   
  CLKSEL    = 0x00;   
   
  SFRPAGE = LEGACY_PAGE;   
  P0MDIN    = 0xFF;   
  P1MDIN   = 0xFF;   
  P2MDIN   = 0xFF;   
  SFRPAGE = CONFIG_PAGE;   
  P3MDIN   = 0xFF;   
  P4MDIN   = 0xFF;   
   
  SFRPAGE = LEGACY_PAGE;   
  P0MDOUT   = 0xDD;   
  P1MDOUT   = 0x90;   
  P2MDOUT   = 0x4D;   
  SFRPAGE = CONFIG_PAGE;   
  P3MDOUT  = 0x1F;   
  P4MDOUT  = 0x00;   
   
  SFRPAGE = LEGACY_PAGE;   
  P0SKIP    = 0xC8;   
  P1SKIP    = 0xFF;   
  P2SKIP    = 0xF8;   
   
  SFRPAGE   = CONFIG_PAGE;   
  P0DRV     = 0xDD;   
  P1DRV     = 0xD0;   
  P2DRV     = 0x4D;   
  P3DRV    = 0x1F;   
  P4DRV    = 0x00;   
   
  SFRPAGE   = LEGACY_PAGE;   
  XBR0      = 0x03;   
  XBR1      = 0x40;   
  XBR2      = 0x40;   
  // Latch all inputs to '1'   
  SFRPAGE   = LEGACY_PAGE;   
  P0 = ~P0MDOUT;   
  P1 = ~P1MDOUT;   
  P2 = ~P2MDOUT;   
  SFRPAGE   = CONFIG_PAGE;   
  P3 = ~P3MDOUT;   
  P4 = ~P4MDOUT;   
  // Set all output to its default state   
  LED1 = 0;   
  LED2 = 0;   
  LED3 = 0;   
  LED4 = 0;   
  MCU_NSEL = 1;   
  EZRP_PWRDN = 0;   
   
}   
   
//-----------------------------------------------------------------------------   
//  Function Name:  _sdcc_external_startup()   
//   
//  Description:    External startup function of SDCC. It performs operations   
//                  prior static and global variable initialisation.   
//                  Watchdog timer should be disabled this way, otherwise it   
//                  can expire before variable initialisation is carried out,   
//                  and may prevent program execution jumping into main().   
//   
//  Return Values:  None   
//   
//  Parameters:     None   
//-----------------------------------------------------------------------------   
#ifdef SDCC   
void _sdcc_external_startup(void)   
{   
   PCA0MD &= ~0x40;         // Disable Watchdog timer   
}   
#endif  
